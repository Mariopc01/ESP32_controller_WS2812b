// Inclui as bibliotecas necessárias
// Instale 'RTClib' e 'FastLED' através do Gerenciador de Bibliotecas da IDE Arduino.
// E certifique-se de ter o suporte para ESP32 instalado (Gerenciador de Placas).
#include <Wire.h>     // Para comunicação I2C com o módulo RTC
#include <RTClib.h>   // Para o módulo Real Time Clock (RTC)
#include <FastLED.h>  // Para controlar as fitas de LED WS2812B/NeoPixel

// --- Configurações da Fita de LED ---
#define LED_PIN     2    // Pino GPIO do ESP32 onde o DATA IN da fita LED está conectado
#define NUM_LEDS    60   // Número de LEDs na sua fita (ajuste conforme o seu comprimento)
#define BRIGHTNESS  127  // Brilho dos LEDs (0-255). 127 é aproximadamente 50% para limitar a corrente.
#define LED_TYPE    WS2812B // Tipo de LED. Se for NeoPixel, pode ser WS2812.
#define COLOR_ORDER GRB  // Ordem das cores. Para WS2812B é GRB. Se as cores estiverem erradas, tente RGB ou BGR.

// Cria um array para armazenar os objetos de LED
CRGB leds[NUM_LEDS];

// --- Configurações do Módulo RTC ---
RTC_DS3231 rtc; // Cria um objeto para o módulo RTC DS3231

// --- Definição das Cores para Cada Dia da Semana ---
// As cores são definidas em formato CRGB
// O array é indexado de Domingo (0) a Sábado (6)
CRGB colorsPerDay[7] = {
    CRGB::Blue,       // Domingo (0)
    CRGB::Yellow,     // Segunda-feira (1)
    CRGB::DeepPink,   // Terça-feira (2) - 'Rosa' mais vibrante
    CRGB::White,      // Quarta-feira (3)
    CRGB::Green,      // Quinta-feira (4)
    CRGB(139, 0, 0),  // Sexta-feira (5) - 'Rubi' (usando valor RGB direto para um tom de vermelho profundo)
    CRGB::Violet      // Sábado (6) - 'Violeta'
};

// Variável para armazenar o dia da semana atual
int currentDay = -1; // Inicializa com um valor que não é um dia da semana válido

// Variável para armazenar a última hora em que a animação horária foi executada
int lastAnimatedHour = -1;

// --- Configurações do Botão ---
#define BUTTON_PIN  23   // Pino GPIO do ESP32 onde o botão está conectado (Ex: GPIO 23)
#define DEBOUNCE_DELAY 50 // Tempo de debounce em milissegundos

int buttonState;        // Estado atual do botão
int lastButtonState = HIGH; // Último estado lido do botão (HIGH porque usaremos INPUT_PULLUP)
unsigned long lastDebounceTime = 0; // Último tempo em que o pino de saída foi alternado

// --- Variáveis de Controle de Modo ---
enum LightMode { NORMAL_MODE, PRESENTATION_MODE };
LightMode currentMode = NORMAL_MODE; // Inicia no modo normal

// --- Variáveis para o Modo Apresentação ---
int presentationFormIndex = 0; // Índice da forma de apresentação atual (0 a 6)
unsigned long formStartTime = 0; // Tempo de início da forma de apresentação atual
const unsigned long FORM_DURATION_MS = 45000; // Duração de cada forma em milissegundos (45 segundos)

// Protótipos das funções de animação (precisam ser declaradas antes de serem usadas)
void animateNewYear(unsigned long duration_ms);
void softBlink(int numBlinks);
void runPresentationForm(int index); // Nova função para rodar as formas de apresentação

void setup() {
    Serial.begin(115200); // Para ESP32, a taxa de baud recomendada para serial é 115200
    while (!Serial); // Aguarda a porta serial conectar (útil para depuração)

    // Configura o pino do botão como entrada com resistor pull-up interno
    pinMode(BUTTON_PIN, INPUT_PULLUP);

    // Inicializa o FastLED e define o brilho global
    FastLED.addLeds<LED_TYPE, LED_PIN, COLOR_ORDER>(leds, NUM_LEDS);
    FastLED.setBrightness(BRIGHTNESS); // <-- CORREÇÃO AQUI!

    // Inicializa o módulo I2C para o RTC
    // Para ESP32, os pinos I2C padrão são GPIO 21 (SDA) e GPIO 22 (SCL).
    Wire.begin(21, 22); // Inicializa I2C nos pinos SDA=GPIO21, SCL=GPIO22

    // Verifica se o módulo RTC está conectado e funcionando
    if (!rtc.begin()) {
        Serial.println("Não foi possível encontrar o módulo RTC!");
        Serial.println("Verifique as conexões ou se a biblioteca está instalada.");
        while (1) delay(100); // Para o programa se o RTC não for encontrado
    }

    // Opcional: Se o RTC perdeu a energia e o horário, defina o horário de compilação do Sketch.
    // Isso é útil para configurar o RTC pela primeira vez.
    // Uma vez que o RTC está funcionando com a bateria, você pode comentar esta linha.
    // rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));

    // Se o RTC não estiver funcionando (por exemplo, bateria fraca ou não instalada),
    // defina o tempo para a data e hora de compilação.
    if (rtc.lostPower()) {
        Serial.println("RTC perdeu energia, definindo a hora para o tempo de compilação!");
        rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
    }

    // Define a cor inicial baseada no dia da semana atual
    DateTime now = rtc.now(); // Obtém a data e hora atuais do RTC
    currentDay = now.dayOfTheWeek(); // Pega o dia da semana (0=domingo, 1=segunda...)
    Serial.print("Dia da semana inicial: ");
    String days[] = {"Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sab"}; // Array para imprimir o dia da semana
    Serial.println(days[currentDay]);
    
    // Define todos os LEDs para a cor do dia atual
    fill_solid(leds, NUM_LEDS, colorsPerDay[currentDay]);
    FastLED.show(); // Envia a cor para a fita de LED

    lastAnimatedHour = now.hour(); // Inicializa a última hora animada para evitar animação no boot.
}

void loop() {
    // --- Leitura e Debounce do Botão ---
    int reading = digitalRead(BUTTON_PIN);

    // Se o estado do botão mudou
    if (reading != lastButtonState) {
        lastDebounceTime = millis(); // Reseta o timer de debounce
    }

    // Se o tempo de debounce passou e o estado ainda é diferente
    if ((millis() - lastDebounceTime) > DEBOUNCE_DELAY) {
        if (reading != buttonState) {
            buttonState = reading;

            if (buttonState == LOW) { // Botão foi pressionado (LOW porque INPUT_PULLUP)
                Serial.println("Botão Pressionado!");
                if (currentMode == NORMAL_MODE) {
                    currentMode = PRESENTATION_MODE;
                    Serial.println("Modo: APRESENTACAO");
                    presentationFormIndex = 0; // Começa da primeira forma
                    formStartTime = millis(); // Inicia o timer da primeira forma
                } else { // currentMode == PRESENTATION_MODE
                    currentMode = NORMAL_MODE;
                    Serial.println("Modo: NORMAL");
                    // Ao voltar para o modo normal, restaura a cor do dia imediatamente
                    fill_solid(leds, NUM_LEDS, colorsPerDay[rtc.now().dayOfTheWeek()]);
                    FastLED.setBrightness(BRIGHTNESS); // Garante brilho normal
                    FastLED.show();
                }
            }
        }
    }
    lastButtonState = reading; // Salva o estado atual para a próxima iteração

    // --- Lógica Principal Baseada no Modo Atual ---
    if (currentMode == NORMAL_MODE) {
        DateTime now = rtc.now(); // Obtém a data e hora atuais do RTC
        int dayOfTheWeek = now.dayOfTheWeek();
        int currentHour = now.hour();
        int currentMinute = now.minute();

        // Imprime a data e hora no Serial Monitor para depuração
        Serial.print(now.year(), DEC);
        Serial.print('/');
        Serial.print(now.month(), DEC);
        Serial.print('/');
        Serial.print(now.day(), DEC);
        Serial.print(" (");
        String days[] = {"Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sab"};
        Serial.print(days[dayOfTheWeek]);
        Serial.print(") ");
        Serial.print(currentHour, DEC);
        Serial.print(':');
        Serial.print(currentMinute, DEC);
        Serial.print(':');
        Serial.print(now.second(), DEC);
        Serial.println(" (Modo NORMAL)");

        // --- Lógica de Animação por Hora ---
        // Verifica se a hora mudou e se é o início de uma nova hora (minuto 0)
        // E garante que a animação só rode uma vez por hora
        if (currentHour != lastAnimatedHour && currentMinute == 0) {
            if (now.month() == 1 && now.day() == 1) { // É 1º de Janeiro? (Mês 1, Dia 1)
                Serial.println("É 1º de Janeiro! Executando animação de Ano Novo por 1 minuto.");
                animateNewYear(60000); // 1 minuto = 60000 milissegundos
            } else {
                Serial.println("Executando piscar suave por 7 vezes.");
                softBlink(7); // Pisca suavemente 7 vezes
            }
            lastAnimatedHour = currentHour; // Atualiza a última hora animada
        }

        // --- Lógica de Mudança de Cor Diária ---
        // Verifica se o dia da semana mudou
        if (dayOfTheWeek != currentDay) {
            currentDay = dayOfTheWeek; // Atualiza o dia da semana
            Serial.print("O dia mudou! Nova cor para ");
            Serial.println(days[currentDay]);

            // Altera a cor de todos os LEDs para a cor do novo dia
            fill_solid(leds, NUM_LEDS, colorsPerDay[currentDay]);
            FastLED.setBrightness(BRIGHTNESS); // Garante que o brilho esteja normal
            FastLED.show(); // Atualiza a fita de LED com a nova cor
        }
    } else { // currentMode == PRESENTATION_MODE
        Serial.print("Modo: APRESENTACAO. Forma ");
        Serial.print(presentationFormIndex + 1);
        Serial.print(" de 7. Tempo restante: ");
        Serial.print((FORM_DURATION_MS - (millis() - formStartTime)) / 1000);
        Serial.println("s.");

        // Avança para a próxima forma se a duração atual expirou
        if (millis() - formStartTime >= FORM_DURATION_MS) {
            presentationFormIndex++;
            if (presentationFormIndex >= 7) {
                presentationFormIndex = 0; // Volta para a primeira forma
            }
            formStartTime = millis(); // Reseta o timer para a nova forma
            Serial.print("Mudando para a forma de apresentação ");
            Serial.println(presentationFormIndex + 1);
        }
        
        // Executa a forma de apresentação atual
        runPresentationForm(presentationFormIndex);
    }
    
    delay(10); // Pequeno atraso para não sobrecarregar o processador e permitir outras tarefas
}

// --- Funções de Animação ---

// Animação para o 1º de Janeiro (dura um período específico) - FUNÇÃO BLOQUEANTE
void animateNewYear(unsigned long duration_ms) {
    unsigned long startTime = millis();
    CRGB currentColor = colorsPerDay[currentDay]; // Salva a cor atual do dia
    
    Serial.println("Iniciando animação de Ano Novo...");
    while (millis() - startTime < duration_ms) {
        // Exemplo de animação: Cores girando (Rainbow Cycle)
        fill_rainbow(leds, NUM_LEDS, millis() / 20); // Ajuste 20 para mudar a velocidade
        FastLED.show();
        delay(10); // Pequeno atraso para suavizar a animação
    }
    // Após a animação, retorna para a cor do dia
    fill_solid(leds, NUM_LEDS, currentColor);
    FastLED.setBrightness(BRIGHTNESS); // Garante que o brilho esteja normal
    FastLED.show();
    Serial.println("Animação de Ano Novo finalizada.");
}

// Piscar suavemente (soft blink) por 'numBlinks' vezes - FUNÇÃO BLOQUEANTE
void softBlink(int numBlinks) {
    CRGB currentColor = colorsPerDay[currentDay]; // Salva a cor atual do dia
    int blinkDuration = 100; // Duração de cada estado (ligado/desligado) do piscar em ms
    int fadeSteps = 10; // Passos para o fade in/out

    Serial.println("Iniciando piscar suave...");
    for (int b = 0; b < numBlinks; b++) {
        // Fade out
        for (int i = BRIGHTNESS; i >= 0; i -= max(1, BRIGHTNESS / fadeSteps)) { // max(1, ...) para evitar divisão por zero se BRIGHTNESS é muito baixo
            FastLED.setBrightness(i);
            fill_solid(leds, NUM_LEDS, currentColor);
            FastLED.show();
            delay(blinkDuration / (fadeSteps * 2)); // Ajuste para duração total do fade
        }
        // Fica desligado por um tempo
        FastLED.setBrightness(0);
        FastLED.show();
        delay(blinkDuration);

        // Fade in
        for (int i = 0; i <= BRIGHTNESS; i += max(1, BRIGHTNESS / fadeSteps)) {
            FastLED.setBrightness(i);
            fill_solid(leds, NUM_LEDS, currentColor);
            FastLED.show();
            delay(blinkDuration / (fadeSteps * 2)); // Ajuste para duração total do fade
        }
        // Garante que o brilho final seja o BRIGHTNESS configurado
        FastLED.setBrightness(BRIGHTNESS);
        fill_solid(leds, NUM_LEDS, currentColor);
        FastLED.show();
        delay(blinkDuration); // Pequeno atraso entre os piscares
    }
    // Garante que a cor final seja a do dia com o brilho normal
    FastLED.setBrightness(BRIGHTNESS);
    fill_solid(leds, NUM_LEDS, currentColor);
    FastLED.show();
    Serial.println("Piscar suave finalizado.");
}

// --- Funções para as 7 Formas de Apresentação (NÃO BLOQUEANTES) ---
// Elas executam apenas um "passo" da animação e são chamadas repetidamente no loop

void runPresentationForm(int index) {
    FastLED.setBrightness(BRIGHTNESS); // Garante que o brilho está definido no modo apresentação

    switch (index) {
        case 0: rainbowCycle(); break;
        case 1: twinkleEffect(); break;
        case 2: cylonScanner(); break;
        case 3: fireEffect(); break;
        case 4: confettiEffect(); break;
        case 5: colorWipe(); break;
        case 6: pulseEffect(); break; // Um pulso de brilho, mais simples que Larson scanner
    }
}

// Forma 0: Ciclo de Arco-Íris
void rainbowCycle() {
    fill_rainbow(leds, NUM_LEDS, beatsin8(20, 0, 255)); // beatsin8 para movimento suave
    FastLED.show();
}

// Forma 1: Twinkle (cintilante)
void twinkleEffect() {
    fadeToBlackBy(leds, NUM_LEDS, 20); // Faz os LEDs existentes desbotarem
    int pixel = random(NUM_LEDS);
    leds[pixel] = CHSV(random8(), 255, 255); // Acende um pixel aleatório com cor aleatória
    FastLED.show();
}

// Forma 2: Cylon/Scanner (luz que vai e volta)
void cylonScanner() {
    static int head = 0;
    static int direction = 1;
    fadeToBlackBy(leds, NUM_LEDS, 60); // Desbota o rastro

    leds[head] = CRGB::Red; // Define a cor da "cabeça"

    head += direction;
    if (head == NUM_LEDS - 1) direction = -1;
    if (head == 0) direction = 1;
    
    FastLED.show();
}

// Forma 3: Efeito de Fogo
void fireEffect() {
    // Array para armazenar o calor de cada pixel
    static byte heat[NUM_LEDS];

    // Passo 1: Resfriar cada pixel um pouco
    for (int i = 0; i < NUM_LEDS; i++) {
        heat[i] = qsub8(heat[i], random8(0, ((NUM_LEDS - i) * 2 / NUM_LEDS) + 2));
    }

    // Passo 2: Faíscas ascendem da base da tira
    if (random8() < 120) { // Ajuste para mais ou menos faíscas
        heat[random8(NUM_LEDS)] = random8(160, 255); // Acende uma faísca em um ponto aleatório
    }

    // Passo 3: Propagar o calor para cima um pixel por vez
    for (int j = NUM_LEDS - 1; j >= 2; j--) {
        heat[j] = (heat[j - 1] + heat[j - 2] + heat[j - 2]) / 3;
    }

    // Passo 4: Mapear calor para cores
    for (int i = 0; i < NUM_LEDS; i++) {
        leds[i] = HeatColor(heat[i]);
    }

    FastLED.show();
}

// Forma 4: Confetti
void confettiEffect() {
    fadeToBlackBy(leds, NUM_LEDS, 10);
    int pos = random16(NUM_LEDS);
    leds[pos] += CHSV(random8(), 200, 255); // Adiciona uma nova partícula de confetti
    FastLED.show();
}

// Forma 5: Color Wipe (varredura de cor)
void colorWipe() {
    static int pixelIndex = 0;
    static CRGB wipeColor = CRGB::Red;
    static int colorChangeCounter = 0;

    leds[pixelIndex] = wipeColor;
    FastLED.show();

    pixelIndex++;
    if (pixelIndex >= NUM_LEDS) {
        pixelIndex = 0;
        colorChangeCounter++;
        if (colorChangeCounter == 1) wipeColor = CRGB::Green;
        else if (colorChangeCounter == 2) wipeColor = CRGB::Blue;
        else {
            wipeColor = CRGB::Red;
            colorChangeCounter = 0;
        }
    }
}

// Forma 6: Pulso de Brilho
void pulseEffect() {
    // Usa beatsin8 para criar um brilho que pulsa suavemente de 0 ao BRIGHTNESS
    uint8_t pulseBrightness = beatsin8(15, 0, BRIGHTNESS); // 15: velocidade, 0-BRIGHTNESS: range
    FastLED.setBrightness(pulseBrightness);
    fill_solid(leds, NUM_LEDS, colorsPerDay[rtc.now().dayOfTheWeek()]); // Mantém a cor do dia
    FastLED.show();
    // Restaura o brilho total para o modo normal (se voltar)
    if (currentMode == NORMAL_MODE) FastLED.setBrightness(BRIGHTNESS);
}
